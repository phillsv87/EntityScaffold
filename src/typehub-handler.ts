import * as fs from 'fs/promises';
import { firstToLower, getPlugin } from './entity-scaffold';
import { TypeHubPlugin } from './typehub-lib';
import { Entity, OutputHandler, ProcessingCtx } from "./types";

export interface TypeHubMember
{
    typeName:string;

}

export const TypeHubOutputHandler:OutputHandler=async (ctx:ProcessingCtx)=>{

    const tsOuts=ctx.args['--hub-out']?.split(',').map(o=>o.trim());
    const exportName=ctx.args['--hub-export-as']?.split(',').map(o=>o.trim());
    const tsHeader=ctx.args['--hub-out-header'];

    if(!tsOuts){
        return;
    }

    const typeHub=getPlugin(ctx,TypeHubPlugin);
    if(!typeHub){
        throw new Error(
            'The TypeHubPlugin is not registered and is required by the TypeHubOutputHandler');
    }

    const tsOut=tsOuts[0];

    const append=(content:string,newline:boolean=true)=>
        fs.appendFile(tsOut,content+(newline?'\n':''));

    await fs.writeFile(tsOut,
    '// this file was auto generated by the EntityScaffold type hub output handler\n');

    if(tsHeader){
        const header=await fs.readFile(tsHeader);
        await fs.appendFile(tsOut,header);
    }
    await append('');

    const imports=typeHub.getImportLines();
    for(const i of imports){
        await append(`${i}`)
    }

    await append('\n');

    const types=typeHub.getTypeMap();


    for(const type in types){

        await append(`class Hub${type}\n{`);

        for(const member of types[type]){
            await append('    '+member.memberBody);
        }

        await append(`}`);

    }

    await append('export class Hub\n{');
    for(const type in types){

        await append(`    public readonly ${type}:Hub${type}=new Hub${type}();`);

    }
    await append('}');

    if(exportName){
        await append(`\nconst ${exportName}=new Hub();\nexport default ${exportName};`)
    }

    for(let i=1;i<tsOuts.length;i++){
        fs.copyFile(tsOut,tsOuts[i]);
    }

}